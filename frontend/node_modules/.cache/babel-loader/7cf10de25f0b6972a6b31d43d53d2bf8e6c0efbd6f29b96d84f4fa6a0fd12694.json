{"ast":null,"code":"import { Position } from \"../../models\";\nimport { tileEmptyOrOpponent, tileIsEmpty } from \"./GenralRules\";\nexport const rookMove = (initialPosition, desiredPosition, side, boardState) => {\n  // Vertical moves\n  for (let i = 1; i < 8; i++) {\n    // If goin down then = -1 else 1\n    let factor = desiredPosition.y < initialPosition.y ? -1 : 1;\n    let prevPosition = new Position(initialPosition.x, initialPosition.y + i * factor);\n    if (prevPosition.samePosition(desiredPosition)) {\n      if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n        return true;\n      }\n    } else {\n      if (!tileIsEmpty(prevPosition, boardState)) {\n        break;\n      }\n    }\n  }\n\n  // Horizontal move\n  if (initialPosition.y === desiredPosition.y) {\n    for (let i = 1; i < 8; i++) {\n      let factor = desiredPosition.x < initialPosition.x ? -1 : 1;\n      let prevPosition = new Position(initialPosition.x + i * factor, initialPosition.y);\n      if (prevPosition.samePosition(desiredPosition)) {\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true;\n        }\n      } else {\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n  }\n  return false;\n};\nexport const getAllRookMoves = (rook, boardState) => {\n  // Store the possible moves in a Position array\n  const possibleMoves = [];\n\n  // Moving Up\n  for (let i = 1; i < 8; i++) {\n    // If the destination position of the rook is outside of the board then break\n    if (rook.position.y + i > 7) break;\n    const destination = new Position(rook.position.x, rook.position.y + i);\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, rook.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Down\n  for (let i = 1; i < 8; i++) {\n    // If the destination position of the rook is outside of the board then break\n    if (rook.position.y - i > 0) break;\n    const destination = new Position(rook.position.x, rook.position.y - i);\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, rook.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Right\n  for (let i = 1; i < 8; i++) {\n    // If the destination position of the rook is outside of the board then break\n    if (rook.position.x + i > 7) break;\n    const destination = new Position(rook.position.x + i, rook.position.y);\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, rook.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Left\n  for (let i = 1; i < 8; i++) {\n    // If the destination position of the rook is outside of the board then break\n    if (rook.position.x - i < 0) break;\n    const destination = new Position(rook.position.x - i, rook.position.y);\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, rook.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","tileEmptyOrOpponent","tileIsEmpty","rookMove","initialPosition","desiredPosition","side","boardState","i","factor","y","prevPosition","x","samePosition","getAllRookMoves","rook","possibleMoves","position","destination","push"],"sources":["/Users/harrisb/Desktop/BetChess/frontend/src/referee/rules/RookRules.ts"],"sourcesContent":["import { Side } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport {\n  tileEmptyOrOpponent,\n  tileIsEmpty,\n} from \"./GenralRules\";\n\nexport const rookMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  side: Side,\n  boardState: Piece[]\n): boolean => {\n  // Vertical moves\n  for (let i = 1; i < 8; i++) {\n    // If goin down then = -1 else 1\n    let factor = desiredPosition.y < initialPosition.y ? -1 : 1;\n    let prevPosition: Position = new Position(initialPosition.x, initialPosition.y + i * factor)\n\n    if (prevPosition.samePosition(desiredPosition)) {\n      if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n        return true;\n      }\n    } else {\n      if (!tileIsEmpty(prevPosition, boardState)) {\n        break;\n      }\n    }\n  }\n\n  // Horizontal move\n  if (initialPosition.y === desiredPosition.y) {\n    for (let i = 1; i < 8; i++) {\n      let factor = desiredPosition.x < initialPosition.x ? -1 : 1;\n      let prevPosition: Position = new Position(initialPosition.x + i * factor, initialPosition.y)\n\n      if (prevPosition.samePosition(desiredPosition)) {\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true;\n        }\n      } else {\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n  }\n  return false;\n};\n\nexport const getAllRookMoves = (\n  rook: Piece,\n  boardState: Piece[]\n): Position[] => {\n  // Store the possible moves in a Position array\n  const possibleMoves: Position[] = [];\n\n  // Moving Up\n  for (let i = 1; i < 8; i++) {\n    // If the destination position of the rook is outside of the board then break\n    if(rook.position.y + i > 7) break;\n\n    const destination: Position = new Position(rook.position.x, rook.position.y + i)\n\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, rook.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Down\n  for (let i = 1; i < 8; i++) {\n    // If the destination position of the rook is outside of the board then break\n    if(rook.position.y - i > 0) break;\n\n    const destination: Position = new Position(rook.position.x, rook.position.y - i)\n\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, rook.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Right\n  for (let i = 1; i < 8; i++) {\n    // If the destination position of the rook is outside of the board then break\n    if(rook.position.x + i > 7) break;\n\n    const destination: Position = new Position(rook.position.x + i, rook.position.y)\n\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, rook.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Left\n  for (let i = 1; i < 8; i++) {\n    // If the destination position of the rook is outside of the board then break\n    if(rook.position.x - i < 0) break;\n\n    const destination: Position = new Position(rook.position.x - i, rook.position.y)\n\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, rook.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  return possibleMoves;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}