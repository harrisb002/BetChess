{"ast":null,"code":"import { Position } from \"../../models\";\nimport { opponentOnTile, tileEmptyOrOpponent, tileIsEmpty } from \"./GenralRules\";\nexport const kingMove = (initialPosition, desiredPosition, side, boardState) => {\n  for (let i = 1; i < 2; i++) {\n    let Xfactor = desiredPosition.x < initialPosition.x ? -1 : desiredPosition.x > initialPosition.x ? 1 : 0;\n    let Yfactor = desiredPosition.y < initialPosition.y ? -1 : desiredPosition.y > initialPosition.y ? 1 : 0;\n    let prevPosition = new Position(initialPosition.x + i * Xfactor, initialPosition.y + i * Yfactor);\n    if (prevPosition.samePosition(desiredPosition)) {\n      if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n        return true;\n      }\n    } else {\n      if (!tileIsEmpty(prevPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n};\nexport const getAllKingMoves = (king, boardstate) => {\n  const possibleMoves = [];\n\n  // Moving Up\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y + i);\n\n    // Bounds checking, if off board then dont add\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Down\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y - i);\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Left\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y);\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Right\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y);\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving to up-right corner\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y + i);\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving up-left corner\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y + i);\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving to bottom-Right corner\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y - i);\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving to bottom-left corner\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y - i);\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};\n\n// Enemy moves have been predetermined before calling this method\nexport const getCastlingMoves = (king, boardState) => {\n  const possibleMoves = [];\n  if (king.hasMoved) return possibleMoves; // Cant castle if king has moved\n\n  //Get the rooks from the same side that have not moved yet\n  const rooks = boardState.filter(piece => piece.isRook && piece.side === king.side && !piece.hasMoved);\n\n  // Check if their are no obstructions (pieces) to castling\n  // The queen side rook should have 3 possible moves, the king side rook should have 2\n  for (const rook of rooks) {\n    var _rook$possibleMoves;\n    // Check direction from rook to king by subtracting x-position of rooks position from king\n    const direction = rook.position.x - king.position.x > 0 ? 1 : -1;\n    // Get the position of the king\n    const adjacentPosition = king.position.clone();\n    // Add that to the direction of the rook \n    adjacentPosition.x += direction;\n\n    // Omit all the rooks that cannot move adjacent to the king\n    if (!((_rook$possibleMoves = rook.possibleMoves) !== null && _rook$possibleMoves !== void 0 && _rook$possibleMoves.some(move => move.samePosition(adjacentPosition)))) continue;\n\n    // Now check if any of the tiles between rook and king are under attack\n    const tilesBetweenRookAndKing = rook.possibleMoves.filter(move => move.y === king.position.y);\n\n    // Get all enemy moves to make sure that they cant move there\n    const opponentPieces = boardState.filter(piece => piece.side !== king.side);\n\n    //Loop through all the opponent pieces, check their possible move, for each check if they contain the positions between rook and king and if so, continue\n    if (opponentPieces.some(piece => {\n      var _piece$possibleMoves;\n      return (_piece$possibleMoves = piece.possibleMoves) === null || _piece$possibleMoves === void 0 ? void 0 : _piece$possibleMoves.some(move => tilesBetweenRookAndKing.some(tile => tile.samePosition(move)));\n    })) continue;\n\n    // Now add the moves to possible moves\n    possibleMoves.push(rook.position.clone());\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","opponentOnTile","tileEmptyOrOpponent","tileIsEmpty","kingMove","initialPosition","desiredPosition","side","boardState","i","Xfactor","x","Yfactor","y","prevPosition","samePosition","getAllKingMoves","king","boardstate","possibleMoves","destination","position","push","getCastlingMoves","hasMoved","rooks","filter","piece","isRook","rook","_rook$possibleMoves","direction","adjacentPosition","clone","some","move","tilesBetweenRookAndKing","opponentPieces","_piece$possibleMoves","tile"],"sources":["/Users/harrisb/Desktop/BetChess/frontend/src/referee/rules/KingRules.ts"],"sourcesContent":["import { Side } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport {\n  opponentOnTile,\n  tileEmptyOrOpponent,\n  tileIsEmpty,\n} from \"./GenralRules\";\n\nexport const kingMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  side: Side,\n  boardState: Piece[]\n): boolean => {\n  for (let i = 1; i < 2; i++) {\n    let Xfactor =\n      desiredPosition.x < initialPosition.x\n        ? -1\n        : desiredPosition.x > initialPosition.x\n          ? 1\n          : 0;\n    let Yfactor =\n      desiredPosition.y < initialPosition.y\n        ? -1\n        : desiredPosition.y > initialPosition.y\n          ? 1\n          : 0;\n\n    let prevPosition: Position = new Position(initialPosition.x + i * Xfactor, initialPosition.y + i * Yfactor);\n\n    if (prevPosition.samePosition(desiredPosition)) {\n      if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n        return true;\n      }\n    } else {\n      if (!tileIsEmpty(prevPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n};\n\nexport const getAllKingMoves = (\n  king: Piece,\n  boardstate: Piece[]\n): Position[] => {\n  const possibleMoves: Position[] = [];\n\n  // Moving Up\n  for (let i = 1; i < 2; i++) {\n    const destination: Position = new Position(king.position.x, king.position.y + i);\n\n    // Bounds checking, if off board then dont add\n    if (\n      destination.x < 0 ||\n      destination.x > 7 ||\n      destination.y < 0 ||\n      destination.y > 7\n    ) {\n      break;\n    }\n\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Down\n  for (let i = 1; i < 2; i++) {\n    const destination: Position = new Position(king.position.x, king.position.y - i)\n\n    if (\n      destination.x < 0 ||\n      destination.x > 7 ||\n      destination.y < 0 ||\n      destination.y > 7\n    ) {\n      break;\n    }\n\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Left\n  for (let i = 1; i < 2; i++) {\n    const destination: Position = new Position(king.position.x - i, king.position.y)\n    if (\n      destination.x < 0 ||\n      destination.x > 7 ||\n      destination.y < 0 ||\n      destination.y > 7\n    ) {\n      break;\n    }\n\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving Right\n  for (let i = 1; i < 2; i++) {\n    const destination: Position = new Position(king.position.x + i, king.position.y)\n    if (\n      destination.x < 0 ||\n      destination.x > 7 ||\n      destination.y < 0 ||\n      destination.y > 7\n    ) {\n      break;\n    }\n\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving to up-right corner\n  for (let i = 1; i < 2; i++) {\n    const destination: Position = new Position(king.position.x + i, king.position.y + i)\n    if (\n      destination.x < 0 ||\n      destination.x > 7 ||\n      destination.y < 0 ||\n      destination.y > 7\n    ) {\n      break;\n    }\n\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving up-left corner\n  for (let i = 1; i < 2; i++) {\n    const destination: Position = new Position(king.position.x - i, king.position.y + i)\n    if (\n      destination.x < 0 ||\n      destination.x > 7 ||\n      destination.y < 0 ||\n      destination.y > 7\n    ) {\n      break;\n    }\n\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving to bottom-Right corner\n  for (let i = 1; i < 2; i++) {\n    const destination: Position = new Position(king.position.x + i, king.position.y - i)\n    if (\n      destination.x < 0 ||\n      destination.x > 7 ||\n      destination.y < 0 ||\n      destination.y > 7\n    ) {\n      break;\n    }\n\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Moving to bottom-left corner\n  for (let i = 1; i < 2; i++) {\n    const destination: Position = new Position(king.position.x - i, king.position.y - i)\n    if (\n      destination.x < 0 ||\n      destination.x > 7 ||\n      destination.y < 0 ||\n      destination.y > 7\n    ) {\n      break;\n    }\n\n    if (tileIsEmpty(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (opponentOnTile(destination, boardstate, king.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  return possibleMoves;\n};\n\n// Enemy moves have been predetermined before calling this method\nexport const getCastlingMoves = (king: Piece, boardState: Piece[]) => {\n  const possibleMoves: Position[] = [];\n  if (king.hasMoved) return possibleMoves; // Cant castle if king has moved\n\n  //Get the rooks from the same side that have not moved yet\n  const rooks = boardState.filter(piece => piece.isRook && piece.side === king.side && !piece.hasMoved);\n\n  // Check if their are no obstructions (pieces) to castling\n  // The queen side rook should have 3 possible moves, the king side rook should have 2\n  for (const rook of rooks) {\n    // Check direction from rook to king by subtracting x-position of rooks position from king\n    const direction = (rook.position.x - king.position.x > 0) ? 1 : -1;\n    // Get the position of the king\n    const adjacentPosition = king.position.clone();\n    // Add that to the direction of the rook \n    adjacentPosition.x += direction;\n\n    // Omit all the rooks that cannot move adjacent to the king\n    if (!rook.possibleMoves?.some(move => move.samePosition(adjacentPosition))) continue;\n\n    // Now check if any of the tiles between rook and king are under attack\n    const tilesBetweenRookAndKing = rook.possibleMoves.filter(move => move.y === king.position.y);\n\n    // Get all enemy moves to make sure that they cant move there\n    const opponentPieces = boardState.filter(piece => piece.side !== king.side);\n\n    //Loop through all the opponent pieces, check their possible move, for each check if they contain the positions between rook and king and if so, continue\n    if (opponentPieces.some(piece => piece.possibleMoves?.some(move => tilesBetweenRookAndKing.some(tile => tile.samePosition(move))))) continue;\n\n    // Now add the moves to possible moves\n    possibleMoves.push(rook.position.clone());\n\n  }\n\n  return possibleMoves;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}