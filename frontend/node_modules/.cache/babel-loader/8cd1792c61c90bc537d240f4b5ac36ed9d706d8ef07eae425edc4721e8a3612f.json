{"ast":null,"code":"import { Position } from \"../../models\";\nimport { tileEmptyOrOpponent } from \"./GenralRules\";\nexport const knightMove = (initialPosition, desiredPosition, side, boardState) => {\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      // For 2 up or down and 1 left or right\n      if (desiredPosition.y - initialPosition.y === 2 * i) {\n        if (desiredPosition.x - initialPosition.x === j) {\n          if (tileEmptyOrOpponent(desiredPosition, boardState, side)) {\n            return true; // Can move or attack the tile\n          }\n        }\n      }\n      // For 2 right or left and 1 up or down\n      if (desiredPosition.x - initialPosition.x === 2 * i) {\n        if (desiredPosition.y - initialPosition.y === j) {\n          if (tileEmptyOrOpponent(desiredPosition, boardState, side)) {\n            return true; // Can move or attack the tile\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\nexport const getAllKnightMoves = (knight, boardState) => {\n  // Store the possible moves in a Position array\n  const possibleMoves = [];\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      // Same as logic above but storing in variables to use\n      const moveVertical = new Position(knight.position.x + j, knight.position.y + i * 2);\n      const moveHorizontal = new Position(knight.position.x + i * 2, knight.position.y + j);\n      if (tileEmptyOrOpponent(moveHorizontal, boardState, knight.side)) {\n        possibleMoves.push(moveHorizontal);\n      }\n      if (tileEmptyOrOpponent(moveVertical, boardState, knight.side)) {\n        possibleMoves.push(moveVertical);\n      }\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","tileEmptyOrOpponent","knightMove","initialPosition","desiredPosition","side","boardState","i","j","y","x","getAllKnightMoves","knight","possibleMoves","moveVertical","position","moveHorizontal","push"],"sources":["/Users/harrisb/Desktop/BetChess/frontend/src/referee/rules/KnightRules.ts"],"sourcesContent":["import { Side } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport {\n  tileEmptyOrOpponent,\n} from \"./GenralRules\";\n\nexport const knightMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  side: Side,\n  boardState: Piece[]\n): boolean => {\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      // For 2 up or down and 1 left or right\n      if (desiredPosition.y - initialPosition.y === 2 * i) {\n        if (desiredPosition.x - initialPosition.x === j) {\n          if (tileEmptyOrOpponent(desiredPosition, boardState, side)) {\n            return true; // Can move or attack the tile\n          }\n        }\n      }\n      // For 2 right or left and 1 up or down\n      if (desiredPosition.x - initialPosition.x === 2 * i) {\n        if (desiredPosition.y - initialPosition.y === j) {\n          if (tileEmptyOrOpponent(desiredPosition, boardState, side)) {\n            return true; // Can move or attack the tile\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\nexport const getAllKnightMoves = (\n  knight: Piece,\n  boardState: Piece[]\n): Position[] => {\n  // Store the possible moves in a Position array\n  const possibleMoves: Position[] = [];\n\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      // Same as logic above but storing in variables to use\n      const moveVertical: Position = new Position(knight.position.x + j, knight.position.y + i * 2)\n      const moveHorizontal: Position = new Position(knight.position.x + i * 2, knight.position.y + j)\n\n      if (tileEmptyOrOpponent(moveHorizontal, boardState, knight.side)) {\n        possibleMoves.push(moveHorizontal);\n      }\n      if (tileEmptyOrOpponent(moveVertical, boardState, knight.side)) {\n        possibleMoves.push(moveVertical);\n      }\n    }\n  }\n  return possibleMoves;\n};\n"],"mappings":"AACA,SAAgBA,QAAQ,QAAQ,cAAc;AAC9C,SACEC,mBAAmB,QACd,eAAe;AAEtB,OAAO,MAAMC,UAAU,GAAGA,CACxBC,eAAyB,EACzBC,eAAyB,EACzBC,IAAU,EACVC,UAAmB,KACP;EACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MAC9B;MACA,IAAIJ,eAAe,CAACK,CAAC,GAAGN,eAAe,CAACM,CAAC,KAAK,CAAC,GAAGF,CAAC,EAAE;QACnD,IAAIH,eAAe,CAACM,CAAC,GAAGP,eAAe,CAACO,CAAC,KAAKF,CAAC,EAAE;UAC/C,IAAIP,mBAAmB,CAACG,eAAe,EAAEE,UAAU,EAAED,IAAI,CAAC,EAAE;YAC1D,OAAO,IAAI,CAAC,CAAC;UACf;QACF;MACF;MACA;MACA,IAAID,eAAe,CAACM,CAAC,GAAGP,eAAe,CAACO,CAAC,KAAK,CAAC,GAAGH,CAAC,EAAE;QACnD,IAAIH,eAAe,CAACK,CAAC,GAAGN,eAAe,CAACM,CAAC,KAAKD,CAAC,EAAE;UAC/C,IAAIP,mBAAmB,CAACG,eAAe,EAAEE,UAAU,EAAED,IAAI,CAAC,EAAE;YAC1D,OAAO,IAAI,CAAC,CAAC;UACf;QACF;MACF;IACF;EACF;EACA,OAAO,KAAK;AACd,CAAC;AAED,OAAO,MAAMM,iBAAiB,GAAGA,CAC/BC,MAAa,EACbN,UAAmB,KACJ;EACf;EACA,MAAMO,aAAyB,GAAG,EAAE;EAEpC,KAAK,IAAIN,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MAC9B;MACA,MAAMM,YAAsB,GAAG,IAAId,QAAQ,CAACY,MAAM,CAACG,QAAQ,CAACL,CAAC,GAAGF,CAAC,EAAEI,MAAM,CAACG,QAAQ,CAACN,CAAC,GAAGF,CAAC,GAAG,CAAC,CAAC;MAC7F,MAAMS,cAAwB,GAAG,IAAIhB,QAAQ,CAACY,MAAM,CAACG,QAAQ,CAACL,CAAC,GAAGH,CAAC,GAAG,CAAC,EAAEK,MAAM,CAACG,QAAQ,CAACN,CAAC,GAAGD,CAAC,CAAC;MAE/F,IAAIP,mBAAmB,CAACe,cAAc,EAAEV,UAAU,EAAEM,MAAM,CAACP,IAAI,CAAC,EAAE;QAChEQ,aAAa,CAACI,IAAI,CAACD,cAAc,CAAC;MACpC;MACA,IAAIf,mBAAmB,CAACa,YAAY,EAAER,UAAU,EAAEM,MAAM,CAACP,IAAI,CAAC,EAAE;QAC9DQ,aAAa,CAACI,IAAI,CAACH,YAAY,CAAC;MAClC;IACF;EACF;EACA,OAAOD,aAAa;AACtB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}