{"ast":null,"code":"import { Position } from \"../../models\";\nimport { tileEmptyOrOpponent, tileIsEmpty } from \"./GenralRules\";\nexport const bishopMove = (initialPosition, desiredPosition, side, boardState) => {\n  // Loop for each tile in the diagonal\n  for (let i = 1; i < 8; i++) {\n    // Right upwards diagonal (inc. x by 1, dec. y by 1)\n    if (desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n      // Get the squares the bishop has moved through\n      let prevPosition = new Position(initialPosition.x + i, initialPosition.y + i);\n\n      // Check if the tile is the where the piece is being moved to\n      if (prevPosition.samePosition(desiredPosition)) {\n        //If tile has a opponent piece on it\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true; // Capture the piece\n        }\n      } else {\n        // Must be a tile being passed\n        // Check if piece on the tile\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    // Right downwards diagonal (inc. x by 1, dec. y by 1)\n    if (desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n      let prevPosition = new Position(initialPosition.x + i, initialPosition.y - i);\n      if (prevPosition.samePosition(desiredPosition)) {\n        //If tile has a opponent piece on it\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true; // Capture the piece\n        }\n      } else {\n        // Must be a tile being passed\n        // Check if piece on the tile\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    // Left downwards diagonal (dec. x by 1, dec. y by 1)\n    if (desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n      let prevPosition = new Position(initialPosition.x - i, initialPosition.y - i);\n\n      // Check if the tile is the where the piece is being moved to\n      if (prevPosition.samePosition(desiredPosition)) {\n        //If tile has a opponent piece on it\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true; // Capture the piece\n        }\n      } else {\n        // Must be a tile being passed\n        // Check if piece on the tile\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    // Left upwards diagonal (dec. x by 1, inc. y by 1)\n    if (desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n      let prevPosition = new Position(initialPosition.x - i, initialPosition.y + i);\n      // Check if the tile is the where the piece is being moved to\n      if (prevPosition.samePosition(desiredPosition)) {\n        //If tile has a opponent piece on it\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true; // Capture the piece\n        }\n      } else {\n        // Must be a tile being passed\n        // Check if piece on the tile\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n  }\n  return false;\n};\nexport const getAllBishopMoves = (bishop, boardState) => {\n  // Store the possible moves in a Position array\n  const possibleMoves = [];\n\n  // Moving up and to the Right\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(bishop.position.x + i, bishop.position.y + i);\n    if (tileIsEmpty(destination, boardState)) {\n      // No piece in the way\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, bishop.side)) {\n      // Opponent piece in the way to capture\n      possibleMoves.push(destination);\n      break;\n    } else {\n      // Must be occupied by same team, thus cannot move through it\n      break;\n    }\n  }\n\n  // Moving up and to the Left\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(bishop.position.x - i, bishop.position.y + i);\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, bishop.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  // Moving down and to the Right\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(bishop.position.x + i, bishop.position.y - i);\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, bishop.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  // Moving down and to the Left\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(bishop.position.x - i, bishop.position.y - i);\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, bishop.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","tileEmptyOrOpponent","tileIsEmpty","bishopMove","initialPosition","desiredPosition","side","boardState","i","x","y","prevPosition","samePosition","getAllBishopMoves","bishop","possibleMoves","destination","position","push"],"sources":["/Users/harrisb/Desktop/BetChess/frontend/src/referee/rules/BishopRules.ts"],"sourcesContent":["import { Side } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport {\n  tileEmptyOrOpponent,\n  tileIsEmpty,\n} from \"./GenralRules\";\n\nexport const bishopMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  side: Side,\n  boardState: Piece[]\n): boolean => {\n  // Loop for each tile in the diagonal\n  for (let i = 1; i < 8; i++) {\n    // Right upwards diagonal (inc. x by 1, dec. y by 1)\n    if (\n      desiredPosition.x > initialPosition.x &&\n      desiredPosition.y > initialPosition.y\n    ) {\n      // Get the squares the bishop has moved through\n      let prevPosition: Position = new Position(initialPosition.x + i, initialPosition.y + i);\n\n      // Check if the tile is the where the piece is being moved to\n      if (prevPosition.samePosition(desiredPosition)) {\n        //If tile has a opponent piece on it\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true; // Capture the piece\n        }\n      } else {\n        // Must be a tile being passed\n        // Check if piece on the tile\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    // Right downwards diagonal (inc. x by 1, dec. y by 1)\n    if (\n      desiredPosition.x > initialPosition.x &&\n      desiredPosition.y < initialPosition.y\n    ) {\n      let prevPosition: Position = new Position(initialPosition.x + i, initialPosition.y - i);\n      if (prevPosition.samePosition(desiredPosition)) {\n        //If tile has a opponent piece on it\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true; // Capture the piece\n        }\n      } else {\n        // Must be a tile being passed\n        // Check if piece on the tile\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    // Left downwards diagonal (dec. x by 1, dec. y by 1)\n    if (\n      desiredPosition.x < initialPosition.x &&\n      desiredPosition.y < initialPosition.y\n    ) {\n      let prevPosition: Position = new Position(initialPosition.x - i, initialPosition.y - i);\n\n      // Check if the tile is the where the piece is being moved to\n      if (prevPosition.samePosition(desiredPosition)) {\n        //If tile has a opponent piece on it\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true; // Capture the piece\n        }\n      } else {\n        // Must be a tile being passed\n        // Check if piece on the tile\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    // Left upwards diagonal (dec. x by 1, inc. y by 1)\n    if (\n      desiredPosition.x < initialPosition.x &&\n      desiredPosition.y > initialPosition.y\n    ) {\n      let prevPosition: Position = new Position(initialPosition.x - i, initialPosition.y + i);\n      // Check if the tile is the where the piece is being moved to\n      if (prevPosition.samePosition(desiredPosition)) {\n        //If tile has a opponent piece on it\n        if (tileEmptyOrOpponent(prevPosition, boardState, side)) {\n          return true; // Capture the piece\n        }\n      } else {\n        // Must be a tile being passed\n        // Check if piece on the tile\n        if (!tileIsEmpty(prevPosition, boardState)) {\n          break;\n        }\n      }\n    }\n  }\n  return false;\n};\n\nexport const getAllBishopMoves = (\n  bishop: Piece,\n  boardState: Piece[]\n): Position[] => {\n  // Store the possible moves in a Position array\n  const possibleMoves: Position[] = [];\n\n  // Moving up and to the Right\n  for (let i = 1; i < 8; i++) {\n    const destination: Position = new Position(bishop.position.x + i, bishop.position.y + i);\n    if (tileIsEmpty(destination, boardState)) {\n      // No piece in the way\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, bishop.side)) {\n      // Opponent piece in the way to capture\n      possibleMoves.push(destination);\n      break;\n    } else {\n      // Must be occupied by same team, thus cannot move through it\n      break;\n    }\n  }\n\n  // Moving up and to the Left\n  for (let i = 1; i < 8; i++) {\n    const destination: Position = new Position(bishop.position.x - i, bishop.position.y + i);\n\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, bishop.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  // Moving down and to the Right\n  for (let i = 1; i < 8; i++) {\n    const destination: Position = new Position(bishop.position.x + i, bishop.position.y - i);\n\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, bishop.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  // Moving down and to the Left\n  for (let i = 1; i < 8; i++) {\n    const destination: Position = new Position(bishop.position.x - i, bishop.position.y - i);\n\n    if (tileIsEmpty(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileEmptyOrOpponent(destination, boardState, bishop.side)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}