{"ast":null,"code":"import { ethers } from 'ethers';\n// or\nimport { Web3Provider } from '@ethersproject/providers';\n// and then use\nconst provider = new Web3Provider(window.ethereum);\nconst abi = [\"event AccountCreated(address owner, uint256 indexed id, uint256 timestamp)\", \"event Deposit(address indexed user, uint256 value, uint256 timestamp)\", \"function accountGames(uint256, uint256) view returns (uint256 gameId, address player1, address player2, uint256 betAmount, address winner, uint256 timestamp)\", \"function accounts(uint256) view returns (address owner, uint256 balance)\", \"function approveBet(uint256 accountId, uint256 amount)\", \"function bet(uint256 accountId, uint256 amount)\", \"function createAccount(address[] newOwner)\", \"function deposit(uint256 accountId) payable\", \"function getAccounts() view returns (uint256[])\", \"function getBalance(uint256 accountId) view returns (uint256)\", \"function getPreviousGames(uint256 accountId) view returns ((uint256 gameId, address player1, address player2, uint256 betAmount, address winner, uint256 timestamp)[])\"];\n\n//Contract address\nconst address = \"0x5FbDB2315678afecb367f032d93F642f64180aa3\";\n\n//Store the contract instance once gained access to metamask from client\nlet contract = null;\nasync function getProviderOrSigner(signer = false) {\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  await provider.send(\"eth_requestAccounts\", []); // Request access\n  return signer ? provider.getSigner() : provider;\n}\nexport async function getContract(signer = false) {\n  if (!contract) {\n    const providerOrSigner = await getProviderOrSigner(signer);\n    contract = new ethers.Contract(address, abi, providerOrSigner);\n  }\n  return contract;\n}\nexport async function createAccount(owner) {\n  const contractWithSigner = await getContract(true);\n  const tx = await contractWithSigner.createAccount(owner);\n  return tx.wait(); // Wait for transaction to be mined\n}\n\n// export async function getAccounts() {\n//   const contract = await getContract();\n//   return contract.getAccounts();\n// }","map":{"version":3,"names":["ethers","Web3Provider","provider","window","ethereum","abi","address","contract","getProviderOrSigner","signer","providers","send","getSigner","getContract","providerOrSigner","Contract","createAccount","owner","contractWithSigner","tx","wait"],"sources":["/Users/harrisb/Desktop/BetChess/frontend/src/ethersService.js"],"sourcesContent":["import { ethers } from 'ethers';\n// or\nimport { Web3Provider } from '@ethersproject/providers';\n// and then use\nconst provider = new Web3Provider(window.ethereum);\n\n\nconst abi = [\n  \"event AccountCreated(address owner, uint256 indexed id, uint256 timestamp)\",\n  \"event Deposit(address indexed user, uint256 value, uint256 timestamp)\",\n  \"function accountGames(uint256, uint256) view returns (uint256 gameId, address player1, address player2, uint256 betAmount, address winner, uint256 timestamp)\",\n  \"function accounts(uint256) view returns (address owner, uint256 balance)\",\n  \"function approveBet(uint256 accountId, uint256 amount)\",\n  \"function bet(uint256 accountId, uint256 amount)\",\n  \"function createAccount(address[] newOwner)\",\n  \"function deposit(uint256 accountId) payable\",\n  \"function getAccounts() view returns (uint256[])\",\n  \"function getBalance(uint256 accountId) view returns (uint256)\",\n  \"function getPreviousGames(uint256 accountId) view returns ((uint256 gameId, address player1, address player2, uint256 betAmount, address winner, uint256 timestamp)[])\",\n];\n\n//Contract address\nconst address = \"0x5FbDB2315678afecb367f032d93F642f64180aa3\";\n\n//Store the contract instance once gained access to metamask from client\nlet contract = null;\n\nasync function getProviderOrSigner(signer = false) {\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  await provider.send(\"eth_requestAccounts\", []); // Request access\n  return signer ? provider.getSigner() : provider;\n}\n\nexport async function getContract(signer = false) {\n  if (!contract) {\n    const providerOrSigner = await getProviderOrSigner(signer);\n    contract = new ethers.Contract(address, abi, providerOrSigner);\n  }\n  return contract;\n}\n\nexport async function createAccount(owner) {\n  const contractWithSigner = await getContract(true);\n  const tx = await contractWithSigner.createAccount(owner);\n  return tx.wait(); // Wait for transaction to be mined\n}\n\n// export async function getAccounts() {\n//   const contract = await getContract();\n//   return contract.getAccounts();\n// }\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAC/B;AACA,SAASC,YAAY,QAAQ,0BAA0B;AACvD;AACA,MAAMC,QAAQ,GAAG,IAAID,YAAY,CAACE,MAAM,CAACC,QAAQ,CAAC;AAGlD,MAAMC,GAAG,GAAG,CACV,4EAA4E,EAC5E,uEAAuE,EACvE,+JAA+J,EAC/J,0EAA0E,EAC1E,wDAAwD,EACxD,iDAAiD,EACjD,4CAA4C,EAC5C,6CAA6C,EAC7C,iDAAiD,EACjD,+DAA+D,EAC/D,wKAAwK,CACzK;;AAED;AACA,MAAMC,OAAO,GAAG,4CAA4C;;AAE5D;AACA,IAAIC,QAAQ,GAAG,IAAI;AAEnB,eAAeC,mBAAmBA,CAACC,MAAM,GAAG,KAAK,EAAE;EACjD,MAAMP,QAAQ,GAAG,IAAIF,MAAM,CAACU,SAAS,CAACT,YAAY,CAACE,MAAM,CAACC,QAAQ,CAAC;EACnE,MAAMF,QAAQ,CAACS,IAAI,CAAC,qBAAqB,EAAE,EAAE,CAAC,CAAC,CAAC;EAChD,OAAOF,MAAM,GAAGP,QAAQ,CAACU,SAAS,CAAC,CAAC,GAAGV,QAAQ;AACjD;AAEA,OAAO,eAAeW,WAAWA,CAACJ,MAAM,GAAG,KAAK,EAAE;EAChD,IAAI,CAACF,QAAQ,EAAE;IACb,MAAMO,gBAAgB,GAAG,MAAMN,mBAAmB,CAACC,MAAM,CAAC;IAC1DF,QAAQ,GAAG,IAAIP,MAAM,CAACe,QAAQ,CAACT,OAAO,EAAED,GAAG,EAAES,gBAAgB,CAAC;EAChE;EACA,OAAOP,QAAQ;AACjB;AAEA,OAAO,eAAeS,aAAaA,CAACC,KAAK,EAAE;EACzC,MAAMC,kBAAkB,GAAG,MAAML,WAAW,CAAC,IAAI,CAAC;EAClD,MAAMM,EAAE,GAAG,MAAMD,kBAAkB,CAACF,aAAa,CAACC,KAAK,CAAC;EACxD,OAAOE,EAAE,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;AACpB;;AAEA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}