{"ast":null,"code":"import { PieceType, Side } from \"../Types\";\nimport { getAllBishopMoves, getAllKingMoves, getAllKnightMoves, getAllPawnMoves, getAllRookMoves, getCastlingMoves } from \"../referee/rules\";\nimport { Position } from \"./Position\";\nexport class Board {\n  constructor(pieces, totalTurns) {\n    this.pieces = void 0;\n    this.totalTurns = void 0;\n    this.winningTeam = void 0;\n    this.pieces = pieces;\n    this.totalTurns = totalTurns;\n  }\n\n  // Get the team whose turn it is\n  get currentSide() {\n    return this.totalTurns % 2 === 0 ? Side.OPPONENT : Side.ALLY;\n  }\n\n  // returns a copy of the board & pieces to update UI with new board\n  clone() {\n    //Create new array with the pieces of the board by cloning each piece in the board into the new copied board\n    return new Board(this.pieces.map(piece => piece.clone()), this.totalTurns);\n  }\n  getAllMoves() {\n    //Find the possible moves for each piece to render them on the board\n    for (const piece of this.pieces) {\n      piece.possibleMoves = this.getValidMoves(piece, this.pieces);\n    }\n\n    //Getting the casting moves for the king\n    for (const king of this.pieces.filter(piece => piece.isKing)) {\n      if (king.possibleMoves === undefined) continue;\n      // Add the possible moves by the king to the added castling moves\n      king.possibleMoves = [...king.possibleMoves, ...getCastlingMoves(king, this.pieces)];\n    }\n\n    //Now check all of the current team moves are valid\n    this.checkAllMovesKingSafety();\n\n    // Get rid of the possible moves for the side that is not moving\n    for (const piece of this.pieces.filter(piece => piece.side !== this.currentSide)) {\n      piece.possibleMoves = [];\n    }\n\n    // Check for checkmate by determining if the team has no possible moves\n    if (this.pieces.filter(piece => piece.side === this.currentSide).some(piece => piece.possibleMoves !== undefined && piece.possibleMoves.length > 0)) return;\n\n    // Set the winning team as the other team has no moves\n    this.winningTeam = this.currentSide === Side.ALLY ? Side.OPPONENT : Side.ALLY;\n  }\n\n  // Loop thru curr team pieces to check validity\n  checkAllMovesKingSafety() {\n    //Loop thru all curr sides pieces by a filter\n    for (const piece of this.pieces.filter(p => p.side === this.currentSide)) {\n      if (piece.possibleMoves === undefined) continue;\n      // Create a simulated board to simulate all the moves for each piece\n      for (const move of piece.possibleMoves) {\n        const simulatedBoard = this.clone();\n\n        // Get rid of each piece that in the same position of the move\n        // This allows the attacking piece to be captured to combat a check\n        simulatedBoard.pieces = simulatedBoard.pieces.filter(piece => !piece.samePosition(move));\n\n        //Clone each piece by first finding each piece based on position\n        // Use ! to mark that pieceClone will be defined\n        const pieceClone = simulatedBoard.pieces.find(p => p.samePiecePosition(piece));\n        //Now update the clone piece position to match the move\n        pieceClone.position = move.clone();\n\n        //Get king with updated position (Also specify that it is not undefined with !)\n        const kingClone = simulatedBoard.pieces.find(piece => piece.isKing && piece.side === simulatedBoard.currentSide);\n\n        //Get all moves for the enemy pieces\n        for (const opponent of simulatedBoard.pieces.filter(p => p.side !== simulatedBoard.currentSide)) {\n          opponent.possibleMoves = simulatedBoard.getValidMoves(opponent, simulatedBoard.pieces); // Pass opponent and boardstate\n\n          // Check validity of moves using the currently updated enemy moves\n          // Find the Pawns to check diaganol attacks\n          if (opponent.isPawn) {\n            //Check x-pos for direction of movement to see if Pawn is threatening king\n            if (opponent.possibleMoves.some(m => m.x !== opponent.position.x && m.samePosition(kingClone.position))) {\n              var _piece$possibleMoves;\n              //Use reference to original king to remove the move as a possible move\n              piece.possibleMoves = (_piece$possibleMoves = piece.possibleMoves) === null || _piece$possibleMoves === void 0 ? void 0 : _piece$possibleMoves.filter(m => !m.samePosition(move));\n            }\n          } else {\n            // If it is not a pawn, just check all moves made by all other pieces\n            if (opponent.possibleMoves.some(m => m.samePosition(kingClone.position))) {\n              var _piece$possibleMoves2;\n              //Use reference to original king to remove the move as a possible move\n              piece.possibleMoves = (_piece$possibleMoves2 = piece.possibleMoves) === null || _piece$possibleMoves2 === void 0 ? void 0 : _piece$possibleMoves2.filter(m => !m.samePosition(move));\n            }\n          }\n        }\n      }\n    }\n  }\n  getValidMoves(piece, boardState) {\n    switch (piece.type) {\n      case PieceType.PAWN:\n        return getAllPawnMoves(piece, boardState);\n      case PieceType.KNIGHT:\n        return getAllKnightMoves(piece, boardState);\n      case PieceType.BISHOP:\n        return getAllBishopMoves(piece, boardState);\n      case PieceType.ROOK:\n        return getAllRookMoves(piece, boardState);\n      case PieceType.QUEEN:\n        return [...getAllBishopMoves(piece, boardState), ...getAllRookMoves(piece, boardState)];\n      case PieceType.KING:\n        return getAllKingMoves(piece, boardState);\n      default:\n        return [];\n    }\n  }\n  makeMove(isEnPassantMove, validMove, pieceInPlay, destination) {\n    const pawnMovement = pieceInPlay.side === Side.ALLY ? 1 : -1;\n    // Get the piece on the tile where the piece is moving to\n    const destinationPiece = this.pieces.find(piece => piece.samePosition(destination));\n\n    // Used for castling moves\n    // Check piece is a king, its destination is a rook, and the rook is of the same team as the piece being moved\n    if (pieceInPlay.isKing && destinationPiece !== null && destinationPiece !== void 0 && destinationPiece.isRook && destinationPiece.side === pieceInPlay.side) {\n      // Find direction from rook to king by subtracting x-position of rooks position from king\n      const direction = destinationPiece.position.x - pieceInPlay.position.x > 0 ? 1 : -1;\n      const newKingXPos = pieceInPlay.position.x + direction * 2;\n      // Pos is right, else left\n      // No pieces are being taken so using map and just modify the new array with the new position of the rook and king\n      this.pieces = this.pieces.map(piece => {\n        // PieceInPlay will be the king\n        if (piece.samePiecePosition(pieceInPlay)) {\n          piece.position.x = newKingXPos;\n        } else if (piece.samePiecePosition(destinationPiece)) {\n          // destinationPiece is the rook\n          piece.position.x = newKingXPos - direction;\n        }\n        return piece;\n      });\n      this.getAllMoves();\n      return true; // Move was valid\n    }\n    if (isEnPassantMove) {\n      this.pieces = this.pieces.reduce((currPieces, piece) => {\n        // Check if its the piece moved\n        if (piece.samePiecePosition(pieceInPlay)) {\n          if (piece.isPawn) piece.enPassant = false;\n\n          // Does not update the reference to pieceInPlay because the piece is being copoed\n          piece.position.x = destination.x;\n          piece.position.y = destination.y;\n          piece.hasMoved = true; // Piece has moved\n          currPieces.push(piece); // Push the updated pieces position\n        } else if (!piece.samePosition(new Position(destination.x, destination.y - pawnMovement))) {\n          if (piece.isPawn) {\n            piece.enPassant = false;\n          }\n          currPieces.push(piece); // Push the updated pieces position\n        }\n        return currPieces;\n      }, []);\n\n      // Update the possible moves inside Referee class\n      this.getAllMoves();\n    } else if (validMove) {\n      this.pieces = this.pieces.reduce((currPieces, piece) => {\n        // Piece that we are currently moving\n        if (piece.samePiecePosition(pieceInPlay)) {\n          //SPECIAL MOVE\n          if (piece.isPawn) piece.enPassant = Math.abs(pieceInPlay.position.y - destination.y) === 2 && piece.type === PieceType.PAWN;\n          piece.position.x = destination.x;\n          piece.position.y = destination.y;\n          piece.hasMoved = true;\n          currPieces.push(piece);\n        } else if (!piece.samePosition(destination)) {\n          if (piece.isPawn) {\n            piece.enPassant = false;\n          }\n          currPieces.push(piece);\n        }\n        return currPieces;\n      }, []);\n\n      // Update the state with the new array of pieces, reflecting any captures and position changes.\n      this.getAllMoves();\n    } else {\n      // If the move isn't valid, do not update the board state and indicate the move was not successful.\n      return false;\n    }\n    return true; // Move has been made successfully\n  }\n}","map":{"version":3,"names":["PieceType","Side","getAllBishopMoves","getAllKingMoves","getAllKnightMoves","getAllPawnMoves","getAllRookMoves","getCastlingMoves","Position","Board","constructor","pieces","totalTurns","winningTeam","currentSide","OPPONENT","ALLY","clone","map","piece","getAllMoves","possibleMoves","getValidMoves","king","filter","isKing","undefined","checkAllMovesKingSafety","side","some","length","p","move","simulatedBoard","samePosition","pieceClone","find","samePiecePosition","position","kingClone","opponent","isPawn","m","x","_piece$possibleMoves","_piece$possibleMoves2","boardState","type","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","makeMove","isEnPassantMove","validMove","pieceInPlay","destination","pawnMovement","destinationPiece","isRook","direction","newKingXPos","reduce","currPieces","enPassant","y","hasMoved","push","Math","abs"],"sources":["/Users/harrisb/Desktop/BetChess/frontend/src/models/Board.ts"],"sourcesContent":["import { PieceType, Side } from \"../Types\";\nimport {\n  getAllBishopMoves,\n  getAllKingMoves,\n  getAllKnightMoves,\n  getAllPawnMoves,\n  getAllRookMoves,\n  getCastlingMoves,\n} from \"../referee/rules\";\nimport { Pawn } from \"./Pawn\";\nimport { Piece } from \"./Piece\";\nimport { Position } from \"./Position\";\n\nexport class Board {\n  pieces: Piece[];\n  totalTurns: number;\n  winningTeam?: Side;\n\n  constructor(pieces: Piece[], totalTurns: number) {\n    this.pieces = pieces;\n    this.totalTurns = totalTurns;\n  }\n\n  // Get the team whose turn it is\n  get currentSide(): Side {\n    return this.totalTurns % 2 === 0 ? Side.OPPONENT : Side.ALLY;\n  }\n\n  // returns a copy of the board & pieces to update UI with new board\n  clone(): Board {\n    //Create new array with the pieces of the board by cloning each piece in the board into the new copied board\n    return new Board(\n      this.pieces.map((piece) => piece.clone()),\n      this.totalTurns\n    );\n  }\n\n  getAllMoves() {\n    //Find the possible moves for each piece to render them on the board\n    for (const piece of this.pieces) {\n      piece.possibleMoves = this.getValidMoves(piece, this.pieces);\n    }\n\n    //Getting the casting moves for the king\n    for (const king of this.pieces.filter((piece) => piece.isKing)) {\n      if (king.possibleMoves === undefined) continue;\n      // Add the possible moves by the king to the added castling moves\n      king.possibleMoves = [\n        ...king.possibleMoves,\n        ...getCastlingMoves(king, this.pieces),\n      ];\n    }\n\n    //Now check all of the current team moves are valid\n    this.checkAllMovesKingSafety();\n\n    // Get rid of the possible moves for the side that is not moving\n    for (const piece of this.pieces.filter(\n      (piece) => piece.side !== this.currentSide\n    )) {\n      piece.possibleMoves = [];\n    }\n\n    // Check for checkmate by determining if the team has no possible moves\n    if (\n      this.pieces\n        .filter((piece) => piece.side === this.currentSide)\n        .some(\n          (piece) =>\n            piece.possibleMoves !== undefined && piece.possibleMoves.length > 0\n        )\n    )\n      return;\n\n    // Set the winning team as the other team has no moves\n    this.winningTeam =\n      this.currentSide === Side.ALLY ? Side.OPPONENT : Side.ALLY;\n  }\n\n  // Loop thru curr team pieces to check validity\n  checkAllMovesKingSafety() {\n    //Loop thru all curr sides pieces by a filter\n    for (const piece of this.pieces.filter(\n      (p) => p.side === this.currentSide\n    )) {\n      if (piece.possibleMoves === undefined) continue;\n      // Create a simulated board to simulate all the moves for each piece\n      for (const move of piece.possibleMoves) {\n        const simulatedBoard = this.clone();\n\n        // Get rid of each piece that in the same position of the move\n        // This allows the attacking piece to be captured to combat a check\n        simulatedBoard.pieces = simulatedBoard.pieces.filter(\n          (piece) => !piece.samePosition(move)\n        );\n\n        //Clone each piece by first finding each piece based on position\n        // Use ! to mark that pieceClone will be defined\n        const pieceClone = simulatedBoard.pieces.find((p) =>\n          p.samePiecePosition(piece)\n        )!;\n        //Now update the clone piece position to match the move\n        pieceClone.position = move.clone();\n\n        //Get king with updated position (Also specify that it is not undefined with !)\n        const kingClone = simulatedBoard.pieces.find(\n          (piece) => piece.isKing && piece.side === simulatedBoard.currentSide\n        )!;\n\n        //Get all moves for the enemy pieces\n        for (const opponent of simulatedBoard.pieces.filter(\n          (p) => p.side !== simulatedBoard.currentSide\n        )) {\n          opponent.possibleMoves = simulatedBoard.getValidMoves(\n            opponent,\n            simulatedBoard.pieces\n          ); // Pass opponent and boardstate\n\n          // Check validity of moves using the currently updated enemy moves\n          // Find the Pawns to check diaganol attacks\n          if (opponent.isPawn) {\n            //Check x-pos for direction of movement to see if Pawn is threatening king\n            if (\n              opponent.possibleMoves.some(\n                (m) =>\n                  m.x !== opponent.position.x &&\n                  m.samePosition(kingClone.position)\n              )\n            ) {\n              //Use reference to original king to remove the move as a possible move\n              piece.possibleMoves = piece.possibleMoves?.filter(\n                (m) => !m.samePosition(move)\n              );\n            }\n          } else {\n            // If it is not a pawn, just check all moves made by all other pieces\n            if (\n              opponent.possibleMoves.some((m) =>\n                m.samePosition(kingClone.position)\n              )\n            ) {\n              //Use reference to original king to remove the move as a possible move\n              piece.possibleMoves = piece.possibleMoves?.filter(\n                (m) => !m.samePosition(move)\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  getValidMoves(piece: Piece, boardState: Piece[]): Position[] {\n    switch (piece.type) {\n      case PieceType.PAWN:\n        return getAllPawnMoves(piece, boardState);\n      case PieceType.KNIGHT:\n        return getAllKnightMoves(piece, boardState);\n      case PieceType.BISHOP:\n        return getAllBishopMoves(piece, boardState);\n      case PieceType.ROOK:\n        return getAllRookMoves(piece, boardState);\n      case PieceType.QUEEN:\n        return [\n          ...getAllBishopMoves(piece, boardState),\n          ...getAllRookMoves(piece, boardState),\n        ];\n      case PieceType.KING:\n        return getAllKingMoves(piece, boardState);\n      default:\n        return [];\n    }\n  }\n\n  makeMove(\n    isEnPassantMove: boolean,\n    validMove: boolean,\n    pieceInPlay: Piece,\n    destination: Position\n  ): boolean {\n    const pawnMovement = pieceInPlay.side === Side.ALLY ? 1 : -1;\n    // Get the piece on the tile where the piece is moving to\n    const destinationPiece = this.pieces.find((piece) =>\n      piece.samePosition(destination)\n    );\n\n    // Used for castling moves\n    // Check piece is a king, its destination is a rook, and the rook is of the same team as the piece being moved\n    if (\n      pieceInPlay.isKing &&\n      destinationPiece?.isRook &&\n      destinationPiece.side === pieceInPlay.side\n    ) {\n      // Find direction from rook to king by subtracting x-position of rooks position from king\n      const direction =\n        destinationPiece.position.x - pieceInPlay.position.x > 0 ? 1 : -1;\n      const newKingXPos = pieceInPlay.position.x + direction * 2;\n      // Pos is right, else left\n      // No pieces are being taken so using map and just modify the new array with the new position of the rook and king\n      this.pieces = this.pieces.map((piece) => {\n        // PieceInPlay will be the king\n        if (piece.samePiecePosition(pieceInPlay)) {\n          piece.position.x = newKingXPos;\n        } else if (piece.samePiecePosition(destinationPiece)) {\n          // destinationPiece is the rook\n          piece.position.x = newKingXPos - direction;\n        }\n        return piece;\n      });\n      this.getAllMoves();\n      return true; // Move was valid\n    }\n\n    if (isEnPassantMove) {\n      this.pieces = this.pieces.reduce((currPieces, piece) => {\n        // Check if its the piece moved\n        if (piece.samePiecePosition(pieceInPlay)) {\n          if (piece.isPawn) (piece as Pawn).enPassant = false;\n\n          // Does not update the reference to pieceInPlay because the piece is being copoed\n          piece.position.x = destination.x;\n          piece.position.y = destination.y;\n          piece.hasMoved = true; // Piece has moved\n          currPieces.push(piece); // Push the updated pieces position\n        } else if (\n          !piece.samePosition(\n            new Position(destination.x, destination.y - pawnMovement)\n          )\n        ) {\n          if (piece.isPawn) {\n            (piece as Pawn).enPassant = false;\n          }\n          currPieces.push(piece); // Push the updated pieces position\n        }\n        return currPieces;\n      }, [] as Piece[]);\n\n      // Update the possible moves inside Referee class\n      this.getAllMoves();\n    } else if (validMove) {\n      this.pieces = this.pieces.reduce((currPieces, piece) => {\n        // Piece that we are currently moving\n        if (piece.samePiecePosition(pieceInPlay)) {\n          //SPECIAL MOVE\n          if (piece.isPawn)\n            (piece as Pawn).enPassant =\n              Math.abs(pieceInPlay.position.y - destination.y) === 2 &&\n              piece.type === PieceType.PAWN;\n          piece.position.x = destination.x;\n          piece.position.y = destination.y;\n          piece.hasMoved = true;\n          currPieces.push(piece);\n        } else if (!piece.samePosition(destination)) {\n          if (piece.isPawn) {\n            (piece as Pawn).enPassant = false;\n          }\n          currPieces.push(piece);\n        }\n        return currPieces;\n      }, [] as Piece[]);\n\n      // Update the state with the new array of pieces, reflecting any captures and position changes.\n      this.getAllMoves();\n    } else {\n      // If the move isn't valid, do not update the board state and indicate the move was not successful.\n      return false;\n    }\n    return true; // Move has been made successfully\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}