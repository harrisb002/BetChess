{"ast":null,"code":"var _jsxFileName = \"/Users/harrisb/Desktop/BetChess/frontend/src/components/Chessboard/Chessboard.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState } from \"react\";\nimport \"./Chessboard.css\";\nimport Tile from \"../Tile/Tile\";\nimport { Position } from \"../../models\";\nimport { X_AXIS, Y_AXIS, GRID_SIZE } from \"../../Constants\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function Chessboard({\n  makeMove,\n  pieces\n}) {\n  _s();\n  // Set active piece to allow for smooth transition of grabbing functionality\n  // Save the grabbed piece in this variable\n  const [activePiece, setActivePiece] = useState(null);\n  // Used to set the x and y position of the peices when dropped to snap to grid\n  const [piecePosition, setPiecePosition] = useState(new Position(-1, -1));\n  const chessboardRef = useRef(null);\n\n  // Functionality to interact with the piece\n  function grabPiece(event) {\n    const chessboard = chessboardRef.current;\n    // Cast the class name to an HTML element\n    const element = event.target;\n    if (element.classList.contains(\"chess-piece\") && chessboard) {\n      const newX = Math.floor((event.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      // Flip y-axis so the mouse lines up with page (board is 800px so can offset it)\n      const newY = Math.abs(Math.ceil((event.clientY - chessboard.offsetTop - 800) / GRID_SIZE));\n      // Set the states of both x and y cordinates of the peice to save location and use in dropPiece function\n      setPiecePosition(new Position(newX, newY));\n\n      // Get the mouse x and y positions\n      const x = event.clientX - GRID_SIZE / 2; // Calculate offset of where the piece is bieng grabbed from top left corner\n      const y = event.clientY - GRID_SIZE / 2;\n      element.style.position = \"absolute\";\n      element.style.left = `${x}px`;\n      element.style.top = `${y}px`;\n\n      // If piece has been grabbed then set it to active\n      setActivePiece(element);\n    }\n  }\n\n  // Used to actuvely move a piece when grabbed and thus \"active\"\n  function movePiece(event) {\n    const chessboard = chessboardRef.current; // To check if null before accessing\n\n    // Only want to move the piece actually being grabbed, not just whats under the mouse\n    // Check if a piece has been grabbed (Must not be null)\n    if (activePiece && chessboard) {\n      // console.log(\"The active piece is: \", activePiece);\n\n      //Getting boundries on board so pieces cant move outside\n      const minX = chessboard.offsetLeft - 25;\n      const minY = chessboard.offsetTop - 25;\n      const maxX = chessboard.offsetLeft + chessboard.clientWidth - 80;\n      const maxY = chessboard.offsetTop + chessboard.clientHeight - 80;\n\n      // Get the mouse s and y positions\n      const x = event.clientX - 50; // Calculate offset of where the piece is bieng grabbed from top left corner\n      const y = event.clientY - 50;\n      activePiece.style.position = \"absolute\";\n\n      //If x is smaller than minimum amount\n      if (x < minX) {\n        activePiece.style.left = `${minX}px`;\n      }\n      //If x is bigger than maximum amount\n      else if (x > maxX) {\n        activePiece.style.left = `${maxX}px`;\n      }\n      //If x is in the constraints\n      else {\n        activePiece.style.left = `${x}px`;\n      }\n      //If y is smaller than minimum amount\n      if (y < minY) {\n        activePiece.style.top = `${minY}px`;\n      }\n      //If y is bigger than maximum amount\n      else if (y > maxY) {\n        activePiece.style.top = `${maxY}px`;\n      }\n      //If y is in the constraints\n      else {\n        activePiece.style.top = `${y}px`;\n      }\n    }\n  }\n  function dropPiece(event) {\n    // Used to find the pieces position relative to the board\n    const chessboard = chessboardRef.current;\n    if (activePiece && chessboard) {\n      // 0,0 is top left of board when offset with the difference of each tile being 100\n      // Finds relative position of pieces to grid\n      const x = Math.floor((event.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      // Flip y-axis so the mouse lines up with page (board is 800px so can offset it)\n      const y = Math.abs(Math.ceil((event.clientY - chessboard.offsetTop - 800) / GRID_SIZE));\n\n      // If the move is valid and a piece is in the location then update the board to remove this piece being captured\n      const currPiece = pieces.find(piece => piece.samePosition(piecePosition));\n\n      // Find the piece being attacked to remove\n      // const pieceAttacked = pieces.find((piece) => piece.XPosition === Xcord && piece.YPosition === Ycord);\n\n      //Only check to set pices for a valid move when there is a current piece being moved\n      if (currPiece) {\n        var success = makeMove(currPiece.clone(), new Position(x, y));\n        if (!success) {\n          // reset the peice position if the piece was not actually moved\n          activePiece.style.position = \"relative\";\n          activePiece.style.removeProperty(\"top\");\n          activePiece.style.removeProperty(\"left\");\n        }\n      }\n      setActivePiece(null);\n    }\n  }\n  let board = [];\n  for (let j = Y_AXIS.length - 1; j >= 0; j--) {\n    for (let i = 0; i < X_AXIS.length; i++) {\n      const number = j + i + 2;\n      // Find in the pieces array each piece in its position defined and to use to place it on the Tile\n      const piece = pieces.find(piece => piece.samePosition(new Position(i, j)));\n\n      // Set image if defined\n      let image = piece ? piece.image : undefined;\n\n      // Find the current piece to determine its possible moves\n      // set active piece if not null and if it is then to undefined so that the highlights are removed when piece is inactive (dropped)\n      let currPiece = activePiece != null ? pieces.find(piece => piece.samePosition(piecePosition)) : undefined;\n\n      // If the current piece is not null then check if the tile is in the possible moves for the piece\n      let highlights = currPiece !== null && currPiece !== void 0 && currPiece.possibleMoves ? currPiece.possibleMoves.some(piece => piece.samePosition(new Position(i, j))) : false;\n\n      // Push the pieces to the board\n      board.push( /*#__PURE__*/_jsxDEV(Tile, {\n        image: image,\n        number: number,\n        highlights: highlights\n      }, `${j},${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 164,\n        columnNumber: 9\n      }, this));\n    }\n  }\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      onMouseMove: event => movePiece(event),\n      onMouseDown: event => grabPiece(event),\n      onMouseUp: event => dropPiece(event),\n      id: \"chessboard\",\n      ref: chessboardRef,\n      children: board\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 176,\n      columnNumber: 7\n    }, this)\n  }, void 0, false);\n}\n_s(Chessboard, \"b8Yr/RFdMrPWOFgKVlQ7Dd8hAl8=\");\n_c = Chessboard;\nvar _c;\n$RefreshReg$(_c, \"Chessboard\");","map":{"version":3,"names":["React","useRef","useState","Tile","Position","X_AXIS","Y_AXIS","GRID_SIZE","jsxDEV","_jsxDEV","Fragment","_Fragment","Chessboard","makeMove","pieces","_s","activePiece","setActivePiece","piecePosition","setPiecePosition","chessboardRef","grabPiece","event","chessboard","current","element","target","classList","contains","newX","Math","floor","clientX","offsetLeft","newY","abs","ceil","clientY","offsetTop","x","y","style","position","left","top","movePiece","minX","minY","maxX","clientWidth","maxY","clientHeight","dropPiece","currPiece","find","piece","samePosition","success","clone","removeProperty","board","j","length","i","number","image","undefined","highlights","possibleMoves","some","push","fileName","_jsxFileName","lineNumber","columnNumber","children","onMouseMove","onMouseDown","onMouseUp","id","ref","_c","$RefreshReg$"],"sources":["/Users/harrisb/Desktop/BetChess/frontend/src/components/Chessboard/Chessboard.tsx"],"sourcesContent":["import React, { useRef, useState } from \"react\";\nimport \"./Chessboard.css\";\nimport Tile from \"../Tile/Tile\";\nimport { Piece, Position } from \"../../models\";\n\nimport {\n  X_AXIS,\n  Y_AXIS,\n  GRID_SIZE,\n} from \"../../Constants\";\n\ninterface Props {\n  makeMove: (piece: Piece, position: Position) => boolean;\n  pieces: Piece[];\n}\n\nexport default function Chessboard({ makeMove, pieces }: Props) {\n  // Set active piece to allow for smooth transition of grabbing functionality\n  // Save the grabbed piece in this variable\n  const [activePiece, setActivePiece] = useState<HTMLElement | null>(null);\n  // Used to set the x and y position of the peices when dropped to snap to grid\n  const [piecePosition, setPiecePosition] = useState<Position>(new Position(-1, -1));\n  const chessboardRef = useRef<HTMLDivElement>(null);\n\n  // Functionality to interact with the piece\n  function grabPiece(event: React.MouseEvent) {\n    const chessboard = chessboardRef.current;\n    // Cast the class name to an HTML element\n    const element = event.target as HTMLElement;\n    if (element.classList.contains(\"chess-piece\") && chessboard) {\n      const newX = Math.floor(\n        (event.clientX - chessboard.offsetLeft) / GRID_SIZE\n      );\n      // Flip y-axis so the mouse lines up with page (board is 800px so can offset it)\n      const newY = Math.abs(\n        Math.ceil((event.clientY - chessboard.offsetTop - 800) / GRID_SIZE)\n      );\n      // Set the states of both x and y cordinates of the peice to save location and use in dropPiece function\n      setPiecePosition(new Position(newX, newY));\n\n      // Get the mouse x and y positions\n      const x = event.clientX - GRID_SIZE / 2; // Calculate offset of where the piece is bieng grabbed from top left corner\n      const y = event.clientY - GRID_SIZE / 2;\n      element.style.position = \"absolute\";\n      element.style.left = `${x}px`;\n      element.style.top = `${y}px`;\n\n      // If piece has been grabbed then set it to active\n      setActivePiece(element);\n    }\n  }\n\n  // Used to actuvely move a piece when grabbed and thus \"active\"\n  function movePiece(event: React.MouseEvent) {\n    const chessboard = chessboardRef.current; // To check if null before accessing\n\n    // Only want to move the piece actually being grabbed, not just whats under the mouse\n    // Check if a piece has been grabbed (Must not be null)\n    if (activePiece && chessboard) {\n      // console.log(\"The active piece is: \", activePiece);\n\n      //Getting boundries on board so pieces cant move outside\n      const minX = chessboard.offsetLeft - 25;\n      const minY = chessboard.offsetTop - 25;\n      const maxX = chessboard.offsetLeft + chessboard.clientWidth - 80;\n      const maxY = chessboard.offsetTop + chessboard.clientHeight - 80;\n\n      // Get the mouse s and y positions\n      const x = event.clientX - 50; // Calculate offset of where the piece is bieng grabbed from top left corner\n      const y = event.clientY - 50;\n      activePiece.style.position = \"absolute\";\n\n      //If x is smaller than minimum amount\n      if (x < minX) {\n        activePiece.style.left = `${minX}px`;\n      }\n      //If x is bigger than maximum amount\n      else if (x > maxX) {\n        activePiece.style.left = `${maxX}px`;\n      }\n      //If x is in the constraints\n      else {\n        activePiece.style.left = `${x}px`;\n      }\n      //If y is smaller than minimum amount\n      if (y < minY) {\n        activePiece.style.top = `${minY}px`;\n      }\n      //If y is bigger than maximum amount\n      else if (y > maxY) {\n        activePiece.style.top = `${maxY}px`;\n      }\n      //If y is in the constraints\n      else {\n        activePiece.style.top = `${y}px`;\n      }\n    }\n  }\n  function dropPiece(event: React.MouseEvent) {\n    // Used to find the pieces position relative to the board\n    const chessboard = chessboardRef.current;\n\n    if (activePiece && chessboard) {\n      // 0,0 is top left of board when offset with the difference of each tile being 100\n      // Finds relative position of pieces to grid\n      const x = Math.floor((event.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      // Flip y-axis so the mouse lines up with page (board is 800px so can offset it)\n      const y = Math.abs(\n        Math.ceil((event.clientY - chessboard.offsetTop - 800) / GRID_SIZE)\n      );\n\n      // If the move is valid and a piece is in the location then update the board to remove this piece being captured\n      const currPiece = pieces.find((piece) =>\n        piece.samePosition(piecePosition)\n      );\n\n      // Find the piece being attacked to remove\n      // const pieceAttacked = pieces.find((piece) => piece.XPosition === Xcord && piece.YPosition === Ycord);\n\n      //Only check to set pices for a valid move when there is a current piece being moved\n      if (currPiece) {\n        var success = makeMove(currPiece.clone(), new Position(x, y));\n\n        if (!success) {\n          // reset the peice position if the piece was not actually moved\n          activePiece.style.position = \"relative\";\n          activePiece.style.removeProperty(\"top\");\n          activePiece.style.removeProperty(\"left\");\n        }\n      }\n      setActivePiece(null);\n    }\n  }\n\n  let board = [];\n\n  for (let j = Y_AXIS.length - 1; j >= 0; j--) {\n    for (let i = 0; i < X_AXIS.length; i++) {\n      const number = j + i + 2;\n      // Find in the pieces array each piece in its position defined and to use to place it on the Tile\n      const piece = pieces.find((piece) =>\n        piece.samePosition(new Position(i, j))\n      );\n\n      // Set image if defined\n      let image = piece ? piece.image : undefined;\n\n      // Find the current piece to determine its possible moves\n      // set active piece if not null and if it is then to undefined so that the highlights are removed when piece is inactive (dropped)\n      let currPiece =\n        activePiece != null\n          ? pieces.find((piece) => piece.samePosition(piecePosition))\n          : undefined;\n\n      // If the current piece is not null then check if the tile is in the possible moves for the piece\n      let highlights = currPiece?.possibleMoves\n        ? currPiece.possibleMoves.some((piece) =>\n          piece.samePosition(new Position(i, j))\n        )\n        : false;\n\n      // Push the pieces to the board\n      board.push(\n        <Tile\n          key={`${j},${i}`}\n          image={image}\n          number={number}\n          highlights={highlights}\n        />\n      );\n    }\n  }\n\n  return (\n    <>\n      <div\n        onMouseMove={(event) => movePiece(event)}\n        onMouseDown={(event) => grabPiece(event)}\n        onMouseUp={(event) => dropPiece(event)}\n        id=\"chessboard\"\n        ref={chessboardRef}\n      >\n        {board}\n      </div>\n    </>\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}